# Nginx Configuration for WAF Integration
# This configuration sets up a reverse proxy with WAF checking

# Define upstream servers
upstream waf_service {
    server 127.0.0.1:8000;
    keepalive 32;
}

upstream backend_app {
    server 127.0.0.1:8080;
    keepalive 32;
}

# Rate limiting for WAF service calls
limit_req_zone $binary_remote_addr zone=waf_check:10m rate=100r/s;
limit_req_zone $binary_remote_addr zone=backend:10m rate=1000r/s;

# Main server block
server {
    listen 80;
    server_name localhost;

    # Access and error logs
    access_log /var/log/nginx/waf_access.log;
    error_log /var/log/nginx/waf_error.log;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Main location block with WAF checking
    location / {
        # Rate limit backend requests
        limit_req zone=backend burst=20 nodelay;

        # Extract request details for WAF check
        set $waf_method $request_method;
        set $waf_uri $request_uri;
        set $waf_query_string $query_string;

        # WAF Check using Lua
        access_by_lua_block {
            local http = require "resty.http"
            local cjson = require "cjson"
            local httpc = http.new()

            -- Rate limit WAF checks
            local limit_req = require "resty.limit.req"
            local lim, err = limit_req.new("waf_check", 100, 10)  -- 100 req/sec with burst of 10
            if not lim then
                ngx.log(ngx.ERR, "failed to instantiate a resty.limit.req object: ", err)
                return ngx.exit(500)
            end

            local delay, err = lim:incoming(ngx.var.binary_remote_addr, true)
            if not delay then
                if err == "rejected" then
                    return ngx.exit(429)  -- Too Many Requests
                end
                ngx.log(ngx.ERR, "failed to limit req: ", err)
                return ngx.exit(500)
            end

            if delay > 0 then
                ngx.sleep(delay / 1000)  -- delay in seconds
            end

            -- Prepare WAF request
            local waf_request = {
                method = ngx.var.request_method,
                path = ngx.var.request_uri,
                query_params = {},
                headers = {},
                body = nil
            }

            -- Parse query parameters
            if ngx.var.query_string and ngx.var.query_string ~= "" then
                for key, value in string.gmatch(ngx.var.query_string, "([^&=]+)=([^&=]+)") do
                    waf_request.query_params[key] = ngx.unescape_uri(value)
                end
            end

            -- Get headers (limit to important ones for performance)
            local important_headers = {
                "user-agent", "accept", "accept-encoding", "accept-language",
                "cache-control", "connection", "host", "referer", "x-forwarded-for"
            }

            for _, header_name in ipairs(important_headers) do
                local header_value = ngx.var["http_" .. string.gsub(header_name, "-", "_")]
                if header_value then
                    waf_request.headers[header_name] = header_value
                end
            end

            -- Get request body for POST/PUT/PATCH
            if ngx.var.request_method == "POST" or
               ngx.var.request_method == "PUT" or
               ngx.var.request_method == "PATCH" then
                ngx.req.read_body()
                local body_data = ngx.req.get_body_data()
                if body_data then
                    -- Limit body size to prevent performance issues
                    if string.len(body_data) > 1024 * 1024 then  -- 1MB limit
                        body_data = string.sub(body_data, 1, 1024 * 1024)
                    end
                    waf_request.body = body_data
                end
            end

            -- Call WAF service
            local res, err = httpc:request_uri("http://127.0.0.1:8000/check", {
                method = "POST",
                body = cjson.encode(waf_request),
                headers = {
                    ["Content-Type"] = "application/json",
                    ["Accept"] = "application/json",
                    ["X-WAF-Client"] = "nginx-proxy"
                },
                timeout = 5000  -- 5 second timeout
            })

            if err then
                ngx.log(ngx.WARN, "WAF service error: ", err)
                -- Fail open: allow request if WAF service is down
                ngx.ctx.waf_status = "service_unavailable"
                return
            end

            if res.status ~= 200 then
                ngx.log(ngx.WARN, "WAF service returned status: ", res.status)
                -- Fail open: allow request on service error
                ngx.ctx.waf_status = "service_error"
                return
            end

            -- Parse WAF response
            local waf_response = cjson.decode(res.body)
            ngx.ctx.waf_score = waf_response.anomaly_score
            ngx.ctx.waf_threshold = waf_response.threshold
            ngx.ctx.waf_processing_time = waf_response.processing_time_ms

            -- Check if anomalous
            if waf_response.is_anomaly then
                ngx.log(ngx.WARN, string.format(
                    "WAF BLOCK: score=%.4f, threshold=%.4f, method=%s, uri=%s, client=%s",
                    waf_response.anomaly_score,
                    waf_response.threshold,
                    ngx.var.request_method,
                    ngx.var.request_uri,
                    ngx.var.remote_addr
                ))

                -- Block the request
                ngx.status = 403
                ngx.header["X-WAF-Blocked"] = "true"
                ngx.header["X-WAF-Score"] = string.format("%.4f", waf_response.anomaly_score)
                ngx.header["X-WAF-Threshold"] = string.format("%.4f", waf_response.threshold)
                ngx.say("Request blocked by Web Application Firewall")
                ngx.exit(403)
            else
                ngx.ctx.waf_status = "allowed"
                ngx.log(ngx.DEBUG, string.format(
                    "WAF ALLOW: score=%.4f, threshold=%.4f, method=%s, uri=%s",
                    waf_response.anomaly_score,
                    waf_response.threshold,
                    ngx.var.request_method,
                    ngx.var.request_uri
                ))
            end
        }

        # Add WAF headers to successful requests
        add_header X-WAF-Status $waf_status;
        add_header X-WAF-Score $waf_score;
        add_header X-WAF-Processing-Time $waf_processing_time;

        # Proxy to backend application
        proxy_pass http://backend_app;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-WAF-Checked "true";

        # Timeout settings
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;

        # Buffer settings
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # WAF metrics proxy
    location /waf-metrics {
        allow 127.0.0.1;
        deny all;

        proxy_pass http://waf_service/metrics;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # Static files (if needed)
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";

        # Still check with WAF for static files
        access_by_lua_block {
            -- Simple WAF check for static files (less strict)
            local static_paths = {"/static/", "/assets/", "/img/", "/css/", "/js/"}
            local is_static = false
            for _, path in ipairs(static_paths) do
                if string.find(ngx.var.request_uri, path) == 1 then
                    is_static = true
                    break
                end
            end

            if not is_static then
                -- For non-static files under static extension, still check
                local http = require "resty.http"
                local cjson = require "cjson"
                local httpc = http.new()

                local waf_request = {
                    method = ngx.var.request_method,
                    path = ngx.var.request_uri,
                    query_params = {},
                    headers = {},
                    body = nil
                }

                local res, err = httpc:request_uri("http://127.0.0.1:8000/check", {
                    method = "POST",
                    body = cjson.encode(waf_request),
                    headers = {["Content-Type"] = "application/json"},
                    timeout = 2000
                })

                if not err and res.status == 200 then
                    local waf_response = cjson.decode(res.body)
                    if waf_response.is_anomaly then
                        ngx.status = 403
                        ngx.say("Request blocked by Web Application Firewall")
                        ngx.exit(403)
                    end
                end
            end
        }

        proxy_pass http://backend_app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# Include additional server blocks if needed
# include /etc/nginx/sites-enabled/*;